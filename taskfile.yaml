version: '3'

dotenv: ['infrastructure/clickup/clickup.env', 'infrastructure/cloudflare/cloudflare.env', 'infrastructure/docker/docker.env']

tasks:

  app:run:
    desc: "Run the Dart app on host (usage: task app:run -- test|prod)"
    silent: true
    vars:
      MODE: { sh: 'ARG="{{.CLI_ARGS}}"; MODE=${ARG%% *}; case "$MODE" in "test"|"") echo "test";; "prod") echo "prod";; *) echo "error";; esac' }
    env:
      CLICKUP_ENV_FILE: "run/{{.MODE}}/clickup.yaml"
      PORT: { sh: 'case "{{.MODE}}" in "test") echo "8081";; "prod") echo "8080";; *) echo "8080";; esac' }
    cmds:
      - |
        if [ "{{.MODE}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'test' or 'prod'"
          exit 1
        fi

        echo "Running app in {{.MODE}} mode..."

        dart run app/lib/main.dart

  app:build:
    desc: "Build the app image (usage: task app:build -- IMAGE_TAG)"
    silent: true
    vars:
      BUILD_MODE: { sh: 'ARG="{{.CLI_ARGS}}"; TAG=${ARG%% *}; if [ -z "$TAG" ] || [ "$TAG" = "dev" ]; then echo "dev"; else echo "prod"; fi' }
      IMAGE_TAG: { sh: 'ARG="{{.CLI_ARGS}}"; TAG=${ARG%% *}; echo ${TAG:-dev}' }
    cmds:
      - |
        if [ "{{.BUILD_MODE}}" = "dev" ]; then
          echo "Building development image..."
          IMAGE_NAME="clickup-listener:{{.IMAGE_TAG}}"
        else
          echo "Building production image with tag: {{.IMAGE_TAG}}"
          if [ -z "$DOCKER_HUB_USERNAME" ]; then
            echo "Error: DOCKER_HUB_USERNAME not set for production build"
            exit 1
          fi
          IMAGE_NAME="$DOCKER_HUB_USERNAME/clickup-listener:{{.IMAGE_TAG}}"
        fi

        echo "Building image: $IMAGE_NAME"
        docker build -f infrastructure/docker/Dockerfile -t "$IMAGE_NAME" .

  app:push:
    desc: "Push the app image to Docker Hub (usage: task app:push -- IMAGE_TAG)"
    silent: true
    vars:
      IMAGE_TAG: { sh: 'ARG="{{.CLI_ARGS}}"; TAG=${ARG%% *}; if [ -z "$TAG" ]; then echo "Error: IMAGE_TAG is required"; exit 1; fi; echo "$TAG"' }
    cmds:
      - |
        if [ -z "$DOCKER_HUB_USERNAME" ]; then
          echo "Error: DOCKER_HUB_USERNAME not set"
          exit 1
        fi
        
        echo "Pushing $DOCKER_HUB_USERNAME/clickup-listener:{{.IMAGE_TAG}} to Docker Hub..."
        
        docker push $DOCKER_HUB_USERNAME/clickup-listener:{{.IMAGE_TAG}}
        
        echo "Successfully pushed $DOCKER_HUB_USERNAME/clickup-listener:{{.IMAGE_TAG}} to Docker Hub"

  app:pull:
    desc: "Pull the app image from Docker Hub (usage: task app:pull -- IMAGE_TAG)"
    silent: true
    vars:
      IMAGE_TAG: { sh: 'ARG="{{.CLI_ARGS}}"; TAG=${ARG%% *}; if [ -z "$TAG" ]; then echo "Error: IMAGE_TAG is required"; exit 1; fi; echo "$TAG"' }
    cmds:
      - |
        if [ -z "$DOCKER_HUB_USERNAME" ]; then
          echo "Error: DOCKER_HUB_USERNAME not set"
          exit 1
        fi
        
        echo "Pulling $DOCKER_HUB_USERNAME/clickup-listener:{{.IMAGE_TAG}} from Docker Hub..."
        
        docker pull $DOCKER_HUB_USERNAME/clickup-listener:{{.IMAGE_TAG}}
        
        echo "Successfully pulled $DOCKER_HUB_USERNAME/clickup-listener:{{.IMAGE_TAG}} from Docker Hub"

  app:start:
    desc: "Start the app container (usage: task app:start -- test|prod [IMAGE_TAG])"
    silent: true
    vars:
      MODE: { sh: 'ARG="{{.CLI_ARGS}}"; MODE=${ARG%% *}; case "$MODE" in "test"|"") echo "test";; "prod") echo "prod";; *) echo "error";; esac' }
      IMAGE_TAG: { sh: 'ARG="{{.CLI_ARGS}}"; set -- $ARG; TAG=${2:-dev}; echo "$TAG"' }
    cmds:
      - |
        if [ "{{.MODE}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'test' or 'prod'"
          exit 1
        fi

        echo "Navigating to run/{{.MODE}} and starting app..."
        cd run/{{.MODE}}
        
        task app:start -- {{.IMAGE_TAG}}


  app:stop:
    desc: "Stop the app container (usage: task app:stop -- test|prod [IMAGE_TAG])"
    silent: true
    vars:
      MODE: { sh: 'ARG="{{.CLI_ARGS}}"; MODE=${ARG%% *}; case "$MODE" in "test"|"") echo "test";; "prod") echo "prod";; *) echo "error";; esac' }
      IMAGE_TAG: { sh: 'ARG="{{.CLI_ARGS}}"; set -- $ARG; TAG=${2:-dev}; echo "$TAG"' }
    cmds:
      - |
        if [ "{{.MODE}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'test' or 'prod'"
          exit 1
        fi

        echo "Navigating to run/{{.MODE}} and stopping app..."
        cd run/{{.MODE}}
        
        task app:stop -- {{.IMAGE_TAG}}

  app:logs:
    desc: "Show app container logs (usage: task app:logs -- test|prod [IMAGE_TAG])"
    silent: true
    vars:
      MODE: { sh: 'ARG="{{.CLI_ARGS}}"; MODE=${ARG%% *}; case "$MODE" in "test"|"") echo "test";; "prod") echo "prod";; *) echo "error";; esac' }
      IMAGE_TAG: { sh: 'ARG="{{.CLI_ARGS}}"; set -- $ARG; TAG=${2:-dev}; echo "$TAG"' }
    cmds:
      - |
        if [ "{{.MODE}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'test' or 'prod'"
          exit 1
        fi

        echo "Navigating to run/{{.MODE}} and showing app logs..."
        cd run/{{.MODE}}
        
        task app:logs -- {{.IMAGE_TAG}}

  tunnel:start:
    desc: "Open the Cloudflare tunnel using Docker Compose (usage: task tunnel:start -- test|prod)"
    silent: true
    vars:
      MODE: { sh: 'ARG="{{.CLI_ARGS}}"; MODE=${ARG%% *}; case "$MODE" in "test"|"") echo "test";; "prod") echo "prod";; *) echo "error";; esac' }
    cmds:
      - |
        if [ "{{.MODE}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'test' or 'prod'"
          exit 1
        fi

        echo "Navigating to run/{{.MODE}} and starting tunnel..."
        cd run/{{.MODE}}
        
        task tunnel:start
  
  tunnel:stop:
    desc: "Stop the Cloudflare tunnel using Docker Compose (usage: task tunnel:stop -- test|prod)"
    silent: true
    vars:
      MODE: { sh: 'ARG="{{.CLI_ARGS}}"; MODE=${ARG%% *}; case "$MODE" in "test"|"") echo "test";; "prod") echo "prod";; *) echo "error";; esac' }
    cmds:
      - |
        if [ "{{.MODE}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'test' or 'prod'"
          exit 1
        fi

        echo "Navigating to run/{{.MODE}} and stopping tunnel..."
        cd run/{{.MODE}}
        
        task tunnel:stop

  tunnel:logs:
    desc: "Show tunnel container logs (usage: task tunnel:logs -- test|prod)"
    silent: true
    vars:
      MODE: { sh: 'ARG="{{.CLI_ARGS}}"; MODE=${ARG%% *}; case "$MODE" in "test"|"") echo "test";; "prod") echo "prod";; *) echo "error";; esac' }
    cmds:
      - |
        if [ "{{.MODE}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'test' or 'prod'"
          exit 1
        fi

        echo "Navigating to run/{{.MODE}} and showing tunnel logs..."
        cd run/{{.MODE}}
        
        task tunnel:logs

  domain:switch:
    desc: "Switch {{.CF_PROD_HOSTNAME}} to {local|remote} (usage: task domain:switch -- local|remote)"
    silent: true
    vars:
      TARGET: { sh: 'ARG="{{.CLI_ARGS}}"; TARGET=${ARG%% *}; case "$TARGET" in "local"|"remote") echo "$TARGET";; *) echo "error";; esac' }
      TTL:        "1"                             # 1 = auto (works when proxied)
      PROXIED:    "true"                          # true/false (boolean in JSON)
    preconditions:
      - sh: '[ -n "$CF_PROD_HOSTNAME" ] && [ -n "$CF_ZONE_ID" ] && [ -n "$CF_RECORD_ID" ] && [ -n "$CF_API_TOKEN" ] && [ -n "$CF_TUNNEL_PROD_LOCAL_ID" ] && [ -n "$CF_TUNNEL_PROD_REMOTE_ID" ]'
        msg: "Missing required variables in cloudflare.env file"
    cmds:
      - |
        if [ "{{.TARGET}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'local' or 'remote'"
          exit 1
        fi

        echo "Switching {{.CF_PROD_HOSTNAME}} to {{.TARGET}} tunnel..."

        if [ "{{.TARGET}}" = "local" ]; then
          curl -sX PUT "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records/$CF_RECORD_ID" \
            -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
            --data "{\"type\":\"CNAME\",\"name\":\"$CF_PROD_HOSTNAME\",\"content\":\"$CF_TUNNEL_PROD_LOCAL_ID\",\"proxied\":{{.PROXIED}},\"ttl\":{{.TTL}}}"
        elif [ "{{.TARGET}}" = "remote" ]; then
          curl -sX PUT "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records/$CF_RECORD_ID" \
            -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
            --data "{\"type\":\"CNAME\",\"name\":\"$CF_PROD_HOSTNAME\",\"content\":\"$CF_TUNNEL_PROD_REMOTE_ID\",\"proxied\":{{.PROXIED}},\"ttl\":{{.TTL}}}"
        fi

  domain:records:
    desc: "Get DNS records for {{.CF_PROD_HOSTNAME}} (usage: task domain:records)"
    silent: true
    preconditions:
      - sh: '[ -n "$CF_ZONE_ID" ] && [ -n "$CF_API_TOKEN" ]'
        msg: "Missing required variables CF_ZONE_ID and CF_API_TOKEN in cloudflare.env file"
    cmds:
      - |
        echo "Getting DNS records for zone: $CF_ZONE_ID"
        echo "---"
        
        # Get all DNS records for the zone
        curl -sX GET "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
          -H "Authorization: Bearer $CF_API_TOKEN" \
          -H "Content-Type: application/json"

  webhooks:activate:
    desc: "Activate ClickUp webhooks for the specified environment (usage: task webhooks:activate -- test|prod)"
    silent: true
    vars:
    env:
      WEBHOOK_IDS: { sh: 'ARG="{{.CLI_ARGS}}"; MODE=${ARG%% *}; case "$MODE" in "test"|"") echo "$CLICKUP_WEBHOOK_IDS_TEST";; "prod") echo "$CLICKUP_WEBHOOK_IDS_PROD";; *) echo "";; esac' }
    cmds:
      - |
        if [ "{{.MODE}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'test' or 'prod'"
          exit 1
        fi
        
        echo "Activating webhooks for {{.MODE}} environment..."
        
        # Process webhook IDs - handle both single and comma-separated values
        if [ -n "$WEBHOOK_IDS" ]; then
          # Split comma-separated webhook IDs using parameter expansion
          # Replace commas with spaces for proper word splitting
          WEBHOOK_IDS_SPACED="${WEBHOOK_IDS//,/ }"
          
          for WEBHOOK_ID in $WEBHOOK_IDS_SPACED; do
            # Simple whitespace removal - remove leading/trailing spaces
            WEBHOOK_ID="${WEBHOOK_ID# }"
            WEBHOOK_ID="${WEBHOOK_ID% }"
            
            if [ -n "$WEBHOOK_ID" ]; then
              echo "Activating webhook ID: $WEBHOOK_ID"
              # Update webhook status to active
              curl -X PUT "https://api.clickup.com/api/v2/webhook/$WEBHOOK_ID" \
                -H "Authorization: $CLICKUP_API_TOKEN" \
                -H "Content-Type: application/json" \
                -d '{"status": "active"}' \
                -w "\nHTTP Status: %{http_code}\n"
              echo "---"
            fi
          done
        else
          echo "No webhook IDs found for environment '{{.CLI_ARGS}}'"
        fi

  webhooks:switch:
    desc: "Switch production webhooks to {local|remote} environment (usage: task webhooks:switch -- local|remote)"
    silent: true
    vars:
      TARGET: { sh: 'ARG="{{.CLI_ARGS}}"; TARGET=${ARG%% *}; case "$TARGET" in "local"|"remote") echo "$TARGET";; *) echo "error";; esac' }
    preconditions:
      - sh: '[ -n "$CLICKUP_API_TOKEN" ] && [ -n "$CLICKUP_WEBHOOK_IDS_PROD" ]'
        msg: "Missing required variables CLICKUP_API_TOKEN and CLICKUP_WEBHOOK_IDS_PROD in clickup.env file"
    cmds:
      - |
        if [ "{{.TARGET}}" = "error" ]; then
          echo "Error: Invalid argument '{{.CLI_ARGS}}'. Use 'local' or 'remote'"
          exit 1
        fi

        echo "Switching production webhooks to {{.TARGET}} environment..."
        echo "New endpoint: http://automation-prod-{{.TARGET}}.ronbal.net/webhooks/clickup"
        echo "---"
        
        # Process webhook IDs - handle comma-separated values
        if [ -n "$CLICKUP_WEBHOOK_IDS_PROD" ]; then
          # Split comma-separated webhook IDs using parameter expansion
          WEBHOOK_IDS_SPACED="${CLICKUP_WEBHOOK_IDS_PROD//,/ }"
          
          for WEBHOOK_ID in $WEBHOOK_IDS_SPACED; do
            # Simple whitespace removal - remove leading/trailing spaces
            WEBHOOK_ID="${WEBHOOK_ID# }"
            WEBHOOK_ID="${WEBHOOK_ID% }"
            
            if [ -n "$WEBHOOK_ID" ]; then
              echo "Updating webhook ID: $WEBHOOK_ID"
              # Update webhook endpoint
              curl -X PUT "https://api.clickup.com/api/v2/webhook/$WEBHOOK_ID" \
                -H "Authorization: $CLICKUP_API_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"endpoint\": \"http://automation-prod-{{.TARGET}}.ronbal.net/webhooks/clickup\"}" \
                -w "\nHTTP Status: %{http_code}\n"
              echo "---"
            fi
          done
        else
          echo "No production webhook IDs found"
        fi